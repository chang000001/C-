# C-
查漏补缺
1、
#include <stdio.h>

void main() 
{
    int m = 3, n = 4, x; 
    x = -m++;                // Step 1
    x = x + 8 / ++n;         // Step 2
    printf("%d\n,%d\n", x, m); // Step 3
}
x = -m++;
m++ 是后置递增操作，即先将 m 的当前值赋给 x，然后再将 m 自增 1，
++n 是前置递增操作，意味着首先将 n 加 1，然后再参与运算

2、
#include <stdio.h>
int main()
{
  	int a[5] = { 10, 20, 30, 40, 50 };
  	int* ptr = (int*)(&a + 1);
  	printf("%d,%d", *(a + 1), *(ptr - 1));
  	return 0;
}

3、int a[5] = { 10, 20, 30, 40, 50 };
定义了一个包含 5 个整数的数组 a，其元素分别为 10, 20, 30, 40, 50。
a 数组的地址是 &a，其类型是 int(*)[5]，即指向包含 5 个 int 的数组的指针

int* ptr = (int*)(&a + 1);
&a 是指向整个数组的指针，类型为 int(*)[5]。
&a + 1 将指针偏移到数组 a 后面的内存位置，指向的是 a 数组的下一块内存（即 a[5] 之后的内存），它的类型是 int(*)[5]。
(int*)(&a + 1) 将这个指针转换为 int* 类型，实际上指向 a[5] 的后一个位置。

*(a + 1) 和 *(ptr - 1)
*(a + 1)：a 是数组名，实际上是数组首元素的地址，a + 1 就是指向数组中第二个元素 a[1] 的地址。*(a + 1) 等价于 a[1]，即 20。
*(ptr - 1)：ptr 指向 a[5] 后的内存位置，ptr - 1 就是指向 a[4] 的位置。*(ptr - 1) 等价于 a[4]，即 50


4、（多选）下列关于单片机中断说法正确的是____。 
A.同一级别的中断请求按时间的先后顺序响应
B.同级中断不能嵌套
C.低优先级中断请求不能中断高优先级中断请求，但是高优先级中断请求能中断低优先级中断请求
D.同一时间同一级别的多中断请求，将形成阻塞，系统无法响应

正确答案：
B. 同级中断不能嵌套
C. 低优先级中断请求不能中断高优先级中断请求，但是高优先级中断请求能中断低优先级中断请求

选项分析：
A. 同一级别的中断请求按时间的先后顺序响应
错误。
同一级别的中断通常按硬件固定优先级决定响应顺序，而不是按时间的先后顺序。例如，某些单片机（如 8051）中断的优先级是由中断源硬件位置决定的，不是按时间先后顺序处理。
D. 同一时间同一级别的多中断请求，将形成阻塞，系统无法响应
错误。
单片机中同级别的多中断请求会通过硬件优先级决定谁先被响应，不会导致系统阻塞或无法响应。

5、下列关于栈的叙述正确的是__B__。 
A.栈按“先进先出”组织数据
B.只能在栈底插入数据
C.栈按“先进后出”组织数据
D.不能删除数据

选项分析：
A. 栈按“先进先出”组织数据
错误。
栈是先进后出（LIFO, Last In First Out） 的数据结构，不是先进先出（FIFO）。先进先出是队列的特性，而不是栈的。
B. 只能在栈底插入数据
错误。
在栈中，数据的插入和删除都只能在 栈顶 进行，而不是在栈底。
C. 栈按“先进后出”组织数据
正确。
栈是 LIFO（Last In First Out） 结构，即最新插入的数据最先被删除。
D. 不能删除数据
错误。
栈可以删除数据，通过弹出（pop）操作，可以将栈顶的数据移出栈。


6、如果char a; char *sp；假定sp指针指向30H地址单元，30H地址单元存放的数为8，31H地址单元存放的数为12，那么进行a=*sp++运算后a的值为____。
A.30H   	B.8   	C.31H  		D.不确定。

解析：
运算过程：
初始条件：
指针 sp 指向地址 30H，即 sp = 30H。
地址 30H 的内容是 8，地址 31H 的内容是 12。
表达式 a = *sp++ 的含义：

运算分为两部分：
*sp：取指针 sp 当前指向的地址单元内容，此时取的是地址 30H 的值 8。
sp++：将指针 sp 的值自增 1，使其指向下一个地址单元，即 31H。
结果：

a 被赋值为 8（*sp 的值）。
sp 的值变为 31H。

7、设 a,b,c 是整型变量，且已正确赋初值，以下选项中错误的赋
值语句是___。 
A.a = 2 = (b = 9) = 1;
B.a = (b = 3) * c;
C.a = b = c / 10;
D.a = 1 % (b = c = 2);

A. a = 2 = (b = 9) = 1;
错误
该语句语法不合法，赋值操作应该从右往左进行，但 2 = (b = 9) = 1 不符合正确的赋值语法。
正确的赋值语句应该是 a = (b = 9) = 1; 或其他适当的表达式。此语句中的 2 = ... 是无意义的，无法作为赋值的目标。
B. a = (b = 3) * c;
正确。
这是一条有效的赋值语句。首先，b 被赋值为 3，然后 a 被赋值为 (b * c) 的结果。
C. a = b = c / 10;
正确。
这也是有效的赋值语句。首先，c / 10 的值被赋给 b，然后 b 的值被赋给 a。
D. a = 1 % (b = c = 2);
正确。
这条语句也有效。首先，c 被赋值为 2，接着 b 被赋值为 2，最后计算 1 % 2 并将结果赋给 a。1 % 2 的结果是 1。

8、在C语言中，关于静态变量的说法,正确的是__B。
A 静态变量和常量的作用相同
B 函数中的静态变量,在函数退出后不被释放
C 静态变量只可以赋值一次,赋值后则不能改变
D 静态全局变量的作用域为一个程序的所有源文件

解析：
静态变量的特点：
静态局部变量：

作用域：静态局部变量的作用域仅限于定义它的函数或代码块，但它的生命周期是程序执行的整个过程。即使函数调用结束，该变量的值仍然保持不变，直到下一次进入函数时，继续使用上次的值。
生命周期：静态变量在程序执行期间一直存在，不会在函数退出时释放。
初始化：静态局部变量在第一次进入其作用域时被初始化（如果未显式初始化，则默认为 0）。
静态全局变量：

作用域：静态全局变量的作用域仅限于定义它的源文件（.c 文件），不能被其他源文件访问。也就是说，静态全局变量 不 能在程序的所有源文件之间共享。
错误选项分析：
A. 静态变量和常量的作用相同：
错误，静态变量和常量的作用不同。常量的值在程序运行期间不能修改，而静态变量的值可以修改。

C. 静态变量只可以赋值一次,赋值后则不能改变：
错误，静态变量可以在程序的执行过程中被修改，虽然它的值在函数退出后保持，但并没有限制只赋值一次。

D. 静态全局变量的作用域为一个程序的所有源文件：
错误，静态全局变量的作用域仅限于定义它的源文件，不会被其他源文件访问。























